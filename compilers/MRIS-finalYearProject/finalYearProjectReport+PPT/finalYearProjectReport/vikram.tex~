\documentclass[onecolumn,10pt]{article}
\usepackage{setspace}
\usepackage{ifpdf}
\usepackage{hyperref}
\usepackage[left=2cm,top=1.5cm,bottom=1.5cm,right=3cm,nohead,nofoot]{geometry}
\newtheorem{mydef}{Definition}
\title{\huge{\underline{\textbf{Minimum Register Instruction Sequence }}}}
\author{}
\date{}
\doublespacing
\begin{document}
\maketitle

\begin{abstract}

\end{abstract}
\section{Introduction}
\subsection{Background}
The compiler mainly consists of two phases -- the frontend and the backend. The lexical analysis and the parsing of the source code is done by the frontend of the compiler.  Lexical analysis phase identifies the tokens and builds the symbol table.  The `parser` conforms the source code with the grammar of the language.  It also performs the semantic analysis. Generally, the Intermediate Representation (IR) is generated by the parser of the frontend. This representation is used by the backend of the compiler and thus an IR provides a link between the high level source code at the frontend and the low level machine instructions of the backend.

Backend mainly consists of the `instruction scheduler` and the `register allocator`. It also consists of optimizations that tries to reduce the compile time and execution time. The intermediate representation is handled by the various passes of the backend which finally converts it into the `object` code. Our project concerns with the optimizations in instruction scheduling to reduce execution time.


Generally, the instructions are re-ordered by analysing the data dependancy graph (DDG) to reduce execution time. But, the number of load/store instructions increases the execution time due to increase in `spill` code. The number of registers are limited in any architecture processor. When the required number of registers are not present to accomodate all the live variables, then some variables are represented in memory and are known as spilled variables. Register pressure is the maximum usage of registers of the processor at any point in the execution sequence of the program. Spilling has more probability with increase in register pressure. Thus if register pressure is reduced, then spilling reduces which ultimately reduces the execution time.

On a processor with instruction-level parallelism, the execution time highly depends on potential parallelism in the program. This program might execute faster if we can \emph{extract} parallelism by reordering instructions from original sequence. In this project we are interested in generating an instruction sequence S that uses minimum registers and therefore defined as Minimum Register Instruction Sequence (MRIS).

\begin{mydef}: {\bf Problem Statement} : Given a data dependence graph G, derive an instruction sequence S for G that is optimal in the sense that its register requirement is minimum.
\end{mydef}

Most of the modern processors are out-of-order instruction issue. False dependencies are handled in out-of-order processors by register renaming. It uses the reservation stations to schedule the instructions whose dependencies are satisfied. Generally, spilling increases the execution time. In out-of-order processors, it decreases parallelism as each load and store reduces the number of dependants. Thus reducing spill codes is important:
\begin{itemize}
\item from a performance point of view in architectures that either have a small cache or a large cache miss penalty;
\item from a memory bandwidth usage viewpoint;
\item from an instrution-level parallelism viewpoint as the elimination of some of the spill instructions frees instruction slots to issue other useful instructions;
\item from a power dissipation viewpoint, as load and store instructions contribute to a significant portion of the power consumed;
\item in multi-threaded architectures, minimizing the number of registers in a thread reduces the cost of a thread context switch.
\end{itemize}











\end{document}